# 불필요한 객체 생성을 피하라. 

- Int 는 -128 ~ 127 까지 캐싱해둔다. 
  - 그래서 동일성 검사를 하면 똑같다. 
- 객체 생성 비용을 따저보자. 
  - 단순히 객체를 wrap 해서 사용하는 것도 비용이 있다. 
    - 64bit JDK 에서는 8바이트 배수 만큼 객체에게 할당한다.
    - 헤더는 12 바이트다. 그럼 일단 최소 16바이트를 사용하는 것. 
    - 레퍼런스 공간으로 8 바이트를 씀. 
    - int 는 4바이트지만 Integer 는 16 바이트. (64 bit jdk 에서는 레퍼런스 비용까지 생각하면 Integer 는 8바이트가 추가된다.)
  - 추가적인 함수 호출 비용.
  - 객체를 생성하고 메모리에 할당하고 레퍼런스를 만드는 것도 다 비용.
- **여기서는 객체의 재사용성을 통해서 불 필요한 객체의 생성 비용을 줄이자. 가 핵심인 것 같다.**

## 캐시 활용 

- 이미 객체를 만들어두고 재사용하는 방식 중 하나. 
- 주로 map 을 이용해서 만듬. 
  - 코틀린 map 에서 `getOrPut() {}` 를 통해서 있으면 꺼내오고, 없으면 넣는 식으로 구현하는 듯. 
  - map 같은 경우는 메모리를 많이 먹으니까 `SoftReference` 를 쓰는걸 권장.
  - 여기서는 SoftReference 와 WeakReference 를 혼돈하지 말라고 말함.
    - SoftReference 는 메모리 압박이 있을 때만 GC 된다. 
    - WeakReference 는 사용할 수 없는 객체에 대해서 GC 된다. 

## 무거운 객체를 외부 스코프로 내보내기

- 여기서 이거는 중복되는 연산을 하지 말자라는 취지
  - 외부로 보내서 한 번만 계산하면 되도록 하자는 것. 
- 정규표현식 같은 객체는 만들떄 무거운데 이를 매번 만들지 않고 한번 만들어놓고 반복해서 쓰는 것. 

## 지연 초기화 

- 사용할 시점까지 생성을 미뤄놓을만한 객체는 미루는게 더 효율이 좋겠지. 
- 지연 초기화를 쓸 땐 메모리 압박이 되는지, 응답 속도가 중요한지 이것만 고려하면 될 듯.

## 기본 자료형 사용하기 

- Int 는 -128 ~ 127 까지 캐싱해서 사용하게 되지만 Integer 는 그렇게 사용하지 않기 때문에 Int 가 더 성능에 좋다.
- Int 대신 Integer 를 쓰게 되는 경우는 다음과 같다. 
  - nullable 일 때 
  - 제네릭을 사용할 때 
- 사실 Int 와 Integer 그렇게 큰 차이는 아닐 수 있지만 거대한 컬렉션을 다룬다면 제법 큰 차이일 수 있다. 이 경우에는 Int 를 사용하도록 하자.
  - 여기서는 100만 ~ 1000만 의 데이터를 Int 와 Integer 를 비교했는데 성능이 두 배 정도 차이가 났다.
