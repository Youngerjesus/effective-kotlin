# item 46: 함수 타입 파라미터를 갖는 함수에 inline 한정자를 붙여라

## inline 이 무엇인가? 

- 함수 호출을 함수 본문으로 대체하는 것. 

## inline 의 장점은 무엇인가? 

- 타입 아규먼트에 `reified` 키워드를 붙여서 사용할 수 있다는 점.

  - 제네릭을 쓰면 컴파일 이후에 JVM 내에서 쓰일 때 타입이 지워진다. 그래서 타입을 참조할 수 없다. 
  
  - `inline` 을 통해서 함수 호출을 함수 본문으로 대체할 수 있고 `reified` 키워드를 통해서 타입을 기억할 수 있다. (`reified` 키워드는 `inline` 함수에서만 사용이 가능하다.)

  - **`reified` 가 나온 이유는 리플렉션을 통해서 타입을 아는게 엄청 느리고, 클라이언트 쪽의 코드가 예쁘지 않아서 나왔다고 한다.** 

    - https://kotlinlang.org/docs/inline-functions.html

  - `reified` 의 유용한 케이스는 `filterIsInstnace` 이다. 실제로 이 구현체를 봐도 `reified` 를 사용한다. 

- 함수가 훨씬 빨라짐 

  - 빨라지는 이유는 함수 호출과 리턴하는 과정에서 점프하는 과정이 없고 백스텍을 추적하는 과정이 없기 떄문에.
    
    - 근데 이러한 차이는 함수 파라미터를 가지지 않는 함수에서는 차이가 크지 않다. 즉 함수 파라미터를 가지는 함수에서는 차이가 큼.
    
  - 그 이유를 알려면 함수를 파라미터로 취급할 때, 객체로 취급할 때 어떠한 변화가 생기는 지를 알면 알기 쉽다.
  
    - 코틀린/js 에서는 함수를 일급 객체로 취급하므로 간단하게 처리가 되는데 코틀린/jvm 에서는 함수 객체를 익명 클래스나, 일반 클래스로 취급이 된다. (wrapping 됨.)
      - () -> Unit 같은 경우는 Function0<Unit> 으로 컴파일 된다. 
      - () -> Int 같은 경우는 Function0<Int> 로 컴파일 된다. 
      - (Int) -> Int 같은 경우는 Function1<Int, Int> 로 컴파일 된다. 
      - (Int, Int) -> Int 같은 경우는 Function2<Int, Int, Int> 로 컴파일 된다. 
    - **즉 함수를 파라미터로 취급하면 래핑되는 과정 떄문에 더욱 느려질 수 있다. 인라인을 쓰면 괜찮음.**
  - 그런 것도 있고 지역 변수를 캡처 하는 과정에서도 인라인 함수와 인라인 함수가 아닌 경우에서의 차이도 있다. 
    - 인라인 함수라면 지역 변수를 그대로 사용하지만 인라인이 아닌 함수는 레퍼런스 객체로 래핑해서 사용한다. 이런 비용의 차이가 성능 차이를 발생시킴.
    - **(100,000 번의 호출 비용을 비교해봤을 때 7배 정도 차이가 났다.)** 

- non-local 리턴을 사용할 수 있다. 

  - non-local 리턴은 함수 내부에서 리턴을 할 수 있는지의 여부다. 
  - inline 이 아닌 함수는 non-local 리턴을 할 수 없다. (익명 클래스나 일반 클래스로 래핑되니까 다시 돌아올 수 없기 떄문에.) (일반 람다는 return 을 쓸 수 없음.)

## inline 을 쓸 수 없는 곳. 

말이 안되는 곳에서는 쓸 수 없다. 
- 재귀 함수인 경우에. 
- 인라인 함수의 가시성이 내부 구현보다 가시성이 높은 경우에. (인라인 함수가 public 이고, 내부가 private, protected 라면 안된다.)

## inline 함수를 받지 못하도록 제어할려면? 

- `crossinline` 으로 타입 파라미터 앞에 선언하면 인라인 함수라도 내부에서 non-local 리턴을 쓸 수 없음.
  - `crossinline` 으로 전달받은 함수에서  `inline` 이 아닌 함수에 또 다른 호출을 해야하는 경우라면 안전하게 `non-local` 리턴이 아닌 함수를 받도록 해야하니까. 
- `noinline` 으로 타입 파라미터 앞에 선언하면 인라인 함수를 받을 수 없음.
